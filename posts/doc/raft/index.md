# 【论文阅读】Raft


论文链接 [In Search of an Understandable Consensus Algorithm (Extended Version)](https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf)

## 1、背景

共识算法是指能够让一组机器在一起协作并且能够容忍部分机器的故障。过去几十年，Paxos是最主流的共识算法，但是它较难理解，在现实中使用需要考虑到很多复杂的变化。于是提出了一种Raft的共识算法，其用于教学和实现更加简单。经过实验测试，在两个大学中对43个学生进行教学，有33个能够较好的理解并回答关于Raft的问题。

作者介绍了三个特性：

**强领导机制**：相比于其他共识算法，Raft具有更强领导人角色。意思是在一组机器中，选出一个领带人，所有的日志数据流由这个领导人发送给其他机器

**领导选举**：Raft使用随机计时器来选举领导，这个方法只是在心跳包机制中引入了一个小改动，能够更简单快速的解决冲突

**成员变动**：Raft在处理集群成员变动中使用了联合共识的方法，在调整过程中两组不同配置的大多数集群都会重叠，这样能够在配置变动中能够正常运行。

## 2、复制状态机

复制状态机是用来解决分布式系统中故障容错性，通常用来管理领导人选举和保存配置信息，使其在出现领导人宕机也能恢复存活。具体的例子有Chubby和Zookeeper。

如下图所示，client提交信息给Server，通常为leader，leader通过共识模块将数据转发给其他client，确保所有的机器的日志最终都保存了相同的请求和顺序，同时把执行的命令写入各自日志条目。当大多数节点确认后，将其标注为已提交。所有的节点将更改保存到各自的状态机，一旦命令被每个机器完整的复制，将输出结果发送给client。

{{&lt; image src=&#34;/img/raft-1.jpg&#34; alt=&#34;图一&#34; width=&#34;400&#34;&gt;}}



复制状态极通常用复制日志来实现，每个服务器保存一组包含指令的日志，能够按照顺序执行。同时保证每个状态机执行的顺序和结果是一致的，内容也是相同。

共识算法的任务正是维护这种复制状态机，由以下特性：

安全性：在出现非拜占庭情况（恶意节点），如网络延迟，数据包丢失，重复等异常情况，不返回错误结果。

可用性：服务器之间能互相通信，在经典的五台服务区中可以允许任意2台故障。故障恢复后能重新加入集群。

容错性：不依赖时序，能处理时钟错误和消息延迟

及时性：一般情况，指令在收到大多数集群相应后快速完成，少速慢节点不影响系统性能。

## 3、Raft共识算法

中间有大篇幅批判Paxos，就此跳过。

Raft是一个管理复制日志的算法，通过选举领导人来实现数据一致性。当领导人收到来自客户端日志条目，会把日志复制给其他服务器，并告诉其他服务器什么时候可以把日志安全的保存在状态机中。总的来说，就是一个领导人管理整个系统，如果领导人挂了，再由新的服务器重新选举。

Raft可以将问题拆分为以下三个独立的子问题，

领导选举：当领导人发生故障的时候，一个新的领导人需要被选举出来，确保系统的连续性和稳定性

日志复制：领导人必须从客户端接收日志条目然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。

安全性：通过状态机来保证安全，如果日志进入了状态机，那么其他服务器就不能在同样的日志索引使用相同命令

### 3.1 Raft基础概念

raft集群中的服务器在任何时候都包含三种状态，领导者，跟随者，候选者。正常的系统中，有一个领导者，其他跟随者是被动的，不能发起请求，只能被动回应领导者和候选者。领导者负责所有的请求，如果客户端向追随者发起请求则会转发给领导者。跟随者在收不到消息时，变为候选人启动选举，获得多数选票的候选人成为领导人。当领导人宕机，则降级为跟随者。

{{&lt; image src=&#34;/img/raft-2.jpg&#34; alt=&#34;图二&#34; width=&#34;400&#34;&gt;}}

Raft将时间划分为任意长度的term，每个term开始于选举，选举出领导人管理集群直到任期结束。理论来说领导人只要一切正常，就能够一直继任。Term充当了逻辑始终的作用，序号随着时间递增。由于服务器之间保存的Term周期会不一致，服务器之间会通过交换term信息，小term会被大term覆盖。

{{&lt; image src=&#34;/img/raft-3.jpg&#34; alt=&#34;图三&#34; width=&#34;400&#34;&gt;}}

Raft服务器之间使用RPC进行通信，仅需要两种类型。RequestVote RPC和AppendEntry RPC，分别用于投票和更新状态机

### 3.2 领导者选举

Raft使用心跳机制来触发领导者选举。服务启动初始状态为跟随者，跟随者永远是跟随者只要它能一直收到来自领导者和候选者的合法RPC。

追随者在一段时间（选举超时）没有收到消息后，开始发起选举。首先会增加它的周期然后变为竞选状态，然后投自己一票，再调用其他服务器的RequestVote，将一直保持这个状态直到出现，

1. 赢得选举
2. 另一个服务器赢得选举
3. 一段时间没有决出胜负

一个服务器每个周期内只能投一票，先进先出原则，先看到谁的拉票就投谁。如果在投票中收到了领导者消息，观察它Term序号是否比自己的序号大，如果是则认可，如果不是则不予理会。

有种特殊情况，所有的跟随者同时都变成了候选者，选票就会分散，没有赢家。这时就会开启新一轮投票，Raft使用了随机延迟机制，每个服务器的选举会随机延迟（150-300ms），这样就能解决问题。

### 3.3 日志复制

选出领导者后开始处理客户端请求，每个请求携带一条被复制状态机执行的指令。领导者将指令作为新日志条目追加至日志中，并并行发起附加条目 RPC 给其他服务器复制，当日志条目被安全复制后，领导者将其状态机执行结果返回给客户端，如果跟随者宕机、延迟或网络丢包，领导者也会持续重试 RPC直至所有跟随者存储所有日志条目。（&lt;u&gt;这里论文没说清楚，如果跟随者下线，一直重发太耗费资源了&lt;/u&gt;）

日志条目按序编号，包含创建时的任期号及待执行指令。日志条目在满足一定条件时变为可提交状态，即安全地应用到状态机中。领导人决定何时提交日志条目，Raft 算法保证所有提交条目持久化并最终被执行。日志条目在被复制到多数服务器时即被提交，包括前任领导人创建的条目。领导人追踪最大已提交条目索引，并在附加条目 RPC 中包含该索引，使跟随者同步应用已提交条目。通过两种方式保证日志的一致性，一是在一个日志索引对应一个条目，且内容和位置不会更改。二是使用AppendEntry RPC时，领导者会携带之前的条目索引和任期编号，如果跟随者找不到这条索引和任期编号就会拒绝日志条目。

{{&lt; image src=&#34;/img/raft-4.jpg&#34; alt=&#34;图四&#34; width=&#34;350&#34;&gt;}}

下图展示了一个特殊的情况，a-b丢失了一些日志条目，c-d或者e有多余未提交的条目。f情况特殊，在term2中当选领导者，刚提交到日志就崩溃了，竞选到term3后提交了一些信息又崩溃了。Raft的处理办法是， 当AppendEntries RPC失败，领导者可以强制覆盖跟随者的日志，领导者为每个追随者维护一个尾指针，表示即将写入的位置。如果出现一致性检查失败，尾指针减一，直到和领导者一致，然后会删除冲突条目，追加领导者条目。

文中提出了一个没什么必要的优化方法，发生AppendEntries RPC冲突时，跟随者主动发送这个冲突任期内的第一个条目，直至不冲突，这样减小比对的次数。

{{&lt; image src=&#34;/img/raft-5.jpg&#34; alt=&#34;图五&#34; width=&#34;350&#34;&gt;}}

## 【未完待续】


---

> 作者: ZergFlood  
> URL: https://careltian.github.io/posts/doc/raft/  

